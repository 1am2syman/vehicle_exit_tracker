# ULTRATHINK: Sub-5s Hybrid OCR (GAS-Only)

> **Created:** 2026-01-14 21:23 BST  
> **Objective:** Achieve <5s perceived response time using only GAS (no Cloudflare)

---

## Revised Architecture: GAS Fast Path

Instead of Cloudflare, we'll create a **lightweight GAS endpoint** that ONLY does the OpenRouter call—no image uploads, no sheet operations. This cuts latency significantly.

### Flow Comparison

```
CURRENT (10-20s):
Frontend → GAS (OCR + Upload + Sheet) → Poll → Result

PROPOSED (4-6s):
├── Track 1: Frontend → GAS/doFastOCR (OpenRouter only) → Result (4-6s) ✓
├── Track 2: Frontend → Tesseract.js (invoices) → Result (2-4s) ✓
└── Track 3: Frontend → GAS/doUpload (images+data) → Background (non-blocking)
```

---

## Deep Reasoning

### Why Not Return API Key to Frontend?

> [!CAUTION]
> Sending the API key to the frontend would allow anyone to:
> - Steal your key via browser DevTools
> - Make unlimited API calls at your expense
> - Require immediate key rotation if discovered

**Instead:** GAS acts as a secure proxy. The API key stays on GAS (Script Properties), frontend never sees it.

### How GAS Fast Path Works

```
┌─────────────────────────────────────────────────────────────────┐
│ NEW ENDPOINT: doGet with action=fastOCR                         │
│                                                                 │
│ Input:  ?action=fastOCR&image=<base64>&type=plate               │
│ Does:   Only calls OpenRouter, returns result                   │
│ Output: { vehicleNumber: "DHAKA METRO-GA 31-9157", conf: 0.95 } │
│ Time:   ~4-6 seconds (just OpenRouter latency)                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ NEW ENDPOINT: doPost with action=upload                         │
│                                                                 │
│ Input:  { images, extractedData, submissionId }                 │
│ Does:   Upload images to Drive, append to Sheet                 │
│ Output: { success: true }                                       │
│ Time:   ~5-8 seconds (runs in background, user doesn't wait)    │
└─────────────────────────────────────────────────────────────────┘
```

### Latency Breakdown

| Step | Current | Proposed |
|------|---------|----------|
| Plate OCR | 10-15s (via polling) | **4-6s** (direct GAS call) |
| Invoice OCR | 10-15s (via polling) | **2-4s** (Tesseract.js) |
| Image upload | Blocking | **Background** (non-blocking) |
| **Total perceived** | **15-20s** | **4-6s** |

---

## Proposed Changes

### [MODIFY] [Code.gs](file:///c:/Users/USER/vehicle_exit_tracker/Code.gs)

Add two new handlers to [doGet](file:///c:/Users/USER/vehicle_exit_tracker/Code.gs#681-751):

```javascript
function doGet(e) {
  const action = e.parameter.action;
  
  if (action === 'fastOCR') {
    // Lightweight: ONLY call OpenRouter, return result
    // No image upload, no sheet append
    return handleFastOCR(e);
  }
  
  // ... existing doGet code for result retrieval
}
```

Add new handler to [doPost](file:///c:/Users/USER/vehicle_exit_tracker/Code.gs#247-424):

```javascript
function doPost(e) {
  const action = e.parameter.action;
  
  if (action === 'upload') {
    // ONLY upload images + append to sheet
    // No OpenRouter call (data already extracted)
    return handleUploadOnly(e);
  }
  
  // ... existing doPost code
}
```

---

### [MODIFY] [index.html](file:///c:/Users/USER/vehicle_exit_tracker/index.html)

Update [processAndSubmit()](file:///c:/Users/USER/vehicle_exit_tracker/index.html#1496-1577) to use parallel calls:

```javascript
async function processAndSubmit() {
  // Start all 3 operations in parallel
  const [plateResult, invoiceResult] = await Promise.all([
    // Track 1: Plate via GAS Fast OCR (4-6s)
    fetchFastOCR(state.platePhoto, 'plate'),
    // Track 2: Invoice via Tesseract.js (2-4s)
    ocrEngine.recognizeInvoice(state.invoicePhotos[0])
  ]);
  
  // Display results immediately (user sees in 4-6s)
  displayResults(plateResult, invoiceResult);
  
  // Track 3: Background upload (user doesn't wait)
  uploadInBackground({
    images: { plate: state.platePhoto, invoices: state.invoicePhotos },
    extractedData: { plateResult, invoiceResult },
    submissionId: state.submissionId
  });
}
```

---

### [MODIFY] [ocr-engine.js](file:///c:/Users/USER/vehicle_exit_tracker/ocr-engine.js)

Simplify to invoice-only:
- Remove [recognizePlate()](file:///c:/Users/USER/vehicle_exit_tracker/ocr-engine.js#390-436) function
- Remove Bengali transliteration tables
- Keep only [recognizeInvoice()](file:///c:/Users/USER/vehicle_exit_tracker/ocr-engine.js#437-492) function

---

## Verification Plan

### Test 1: Plate OCR via Fast Path
```
1. Capture plate image
2. Measure: Click → Vehicle number displayed
3. Pass: < 6 seconds
```

### Test 2: Invoice OCR via Tesseract
```
1. Capture invoice image  
2. Measure: Click → Invoice number displayed
3. Pass: < 4 seconds
```

### Test 3: Background Upload
```
1. Submit with both images
2. Check Google Sheet for new row
3. Pass: Row appears within 15 seconds
```

---

## User Review Required

> [!IMPORTANT]
> **Confirm Approach**
> 
> This GAS-only approach adds two lightweight handlers to your existing [Code.gs](file:///c:/Users/USER/vehicle_exit_tracker/Code.gs).
> No new infrastructure needed—just deploy an updated version of your script.
> 
> Ready to proceed with implementation?

> **Created:** 2026-01-14 21:17 BST  
> **Objective:** Achieve <5s perceived response time for all OCR operations

---

## Executive Summary

**Current Problem:** User waits 10-20s because images round-trip through GAS→OpenRouter→GAS→Frontend.

**Proposed Solution:** 
- **Plates**: Frontend → Cloudflare Worker → OpenRouter → Frontend (3-5s)
- **Invoices**: Frontend → Tesseract.js (2-4s)
- **Images**: Background upload to GAS (non-blocking)

**Result:** OCR results display in <5s, images upload silently in parallel.

---

## Deep Reasoning Chain

### 1. Why Can't Frontend Call OpenRouter Directly?

**Security Risk:** Exposing `OPENROUTER_API_KEY` in client-side JavaScript allows:
- Anyone to steal the key via DevTools
- Unlimited API usage at your expense
- Key revocation required if discovered

**Solution:** Use an **edge proxy** that:
1. Receives image from frontend (no API key included)
2. Adds API key server-side (from environment secret)
3. Forwards to OpenRouter
4. Returns result to frontend

### 2. Why Cloudflare Worker Over Other Options?

| Option | Latency | Cost | Security | Complexity |
|--------|---------|------|----------|------------|
| **Cloudflare Worker** | ~50ms overhead | Free (100k/day) | ✅ Secrets | Low |
| Vercel Edge Function | ~50ms overhead | Free tier | ✅ Secrets | Low |
| GAS "Fast Path" | ~500ms overhead | Free | ⚠️ Same origin | Medium |
| AWS Lambda@Edge | ~100ms overhead | Paid | ✅ Secrets | High |

**Decision:** Cloudflare Worker. Free tier covers 100,000 requests/day. Global edge network minimizes latency to OpenRouter.

### 3. Latency Breakdown

```
┌─────────────────────────────────────────────────────────────────┐
│ CURRENT FLOW (10-20 seconds)                                    │
├─────────────────────────────────────────────────────────────────┤
│ Frontend → GAS POST (~500ms)                                    │
│ GAS → OpenRouter API (~3-5s)                                    │
│ GAS → Drive upload (~2-3s)                                      │
│ GAS → Sheet append (~500ms)                                     │
│ Frontend polling (~5-10s wait + retries)                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ PROPOSED FLOW (3-5 seconds perceived)                           │
├─────────────────────────────────────────────────────────────────┤
│ PARALLEL TRACK 1: OCR (user-facing)                             │
│   Plate: Frontend → CF Worker → OpenRouter → Frontend (3-5s)    │
│   Invoice: Frontend → Tesseract.js → Display (2-4s)             │
├─────────────────────────────────────────────────────────────────┤
│ PARALLEL TRACK 2: Upload (background)                           │
│   Frontend → GAS POST (images + extracted data) → Done          │
│   User doesn't wait for this!                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 4. Architecture Diagram

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant T as Tesseract.js
    participant C as CF Worker
    participant O as OpenRouter
    participant G as GAS
    participant D as Drive
    
    U->>F: Capture Plate + Invoice
    
    par Plate OCR (3-5s)
        F->>C: POST plate image
        C->>O: Forward with API key
        O-->>C: GPT-4o result
        C-->>F: Vehicle number
        F->>U: Display plate result ✓
    and Invoice OCR (2-4s)
        F->>T: Process invoice image
        T-->>F: Invoice numbers
        F->>U: Display invoice result ✓
    and Background Upload (5-8s, hidden)
        F->>G: POST images + extracted data
        G->>D: Upload to Drive
        G->>G: Append to Sheet
    end
    
    F->>U: Ready to submit!
```

### 5. Security Analysis

| Attack Vector | Mitigation |
|---------------|------------|
| API key theft | Key stored in CF Worker secret, never sent to client |
| Replay attacks | Rate limiting on CF Worker (100 req/min per IP) |
| Image injection | Validate base64 format, max 2MB size |
| CORS bypass | CF Worker returns proper CORS headers |
| DoS | Cloudflare built-in DDoS protection |

### 6. Offline / Failure Handling

| Scenario | Behavior |
|----------|----------|
| CF Worker unreachable | Fallback to GAS route (slower but works) |
| OpenRouter timeout | Return error, user can retry |
| Tesseract fails | Fallback to CF Worker for invoice |
| GAS upload fails | Queue in localStorage, retry on next visit |
| No internet | Tesseract works offline for invoices; plates queued |

---

## Proposed Changes

### [NEW] Cloudflare Worker

Deploy to `https://ocr-proxy.YOUR_SUBDOMAIN.workers.dev`

```javascript
// Handles POST /plate with base64 image
// Returns { vehicleNumber, confidence }
```

---

### [MODIFY] [index.html](file:///c:/Users/USER/vehicle_exit_tracker/index.html)

**Changes:**
1. Add `CF_WORKER_URL` to config
2. New `processPlateWithAI()` function calls CF Worker directly
3. [processAndSubmit()](file:///c:/Users/USER/vehicle_exit_tracker/index.html#1496-1577) runs plate OCR + invoice OCR + upload in parallel
4. Display results as soon as each completes (progressive UI)

---

### [MODIFY] [ocr-engine.js](file:///c:/Users/USER/vehicle_exit_tracker/ocr-engine.js)

**Changes:**
1. Remove plate processing functions
2. Remove Bengali transliteration tables
3. Keep only [recognizeInvoice()](file:///c:/Users/USER/vehicle_exit_tracker/ocr-engine.js#437-492) function
4. Reduce file size from 22KB to ~8KB

---

### [MODIFY] [Code.gs](file:///c:/Users/USER/vehicle_exit_tracker/Code.gs)

**Changes:**
1. Accept `extractedData` parameter with pre-OCR'd values
2. Skip OpenRouter call entirely when `extractedData` provided
3. Only handle: image upload + sheet append
4. Processing time drops from ~10s to ~3s

---

## Verification Plan

### Test 1: Plate OCR Latency
1. Open app in browser with DevTools Network tab
2. Capture plate image
3. Measure time from capture → vehicle number displayed
4. **Pass criteria:** <5 seconds

### Test 2: Invoice OCR Latency  
1. Capture invoice image
2. Measure time from capture → invoice number displayed
3. **Pass criteria:** <4 seconds

### Test 3: Total Submission Time
1. Capture plate + invoice
2. Click submit
3. Measure time until success screen
4. **Pass criteria:** Results shown in <5s, upload completes in <15s

### Test 4: Offline Invoice OCR
1. Load app with internet
2. Disable network
3. Capture and process invoice
4. **Pass criteria:** Invoice number extracted without network

---

## User Review Required

> [!IMPORTANT]
> **Cloudflare Account Required**
> 
> You'll need a (free) Cloudflare account to deploy the Worker proxy.
> - Do you have a Cloudflare account, or should I provide setup steps?
> - Alternative: I can use Vercel Edge Functions instead if you prefer.

> [!IMPORTANT]  
> **OpenRouter API Key Storage**
> 
> The API key will be stored in Cloudflare Worker secrets (not in code).
> - This is the same key currently in your GAS script properties
> - It won't be accessible to frontend or visible in source code
